### Spring Security

- A powerful framework providing authentication and authorization (or access control) functionalities.
- The standard for securing applications built on the Spring framework.
- Designed with extensibility in mind, making it easy to add and modify various security requirements.

**Why use Social Login?** Implementing all security features manually can be cumbersome. Social login providers handle tasks like:
- Security during login
- Email or phone number verification during sign-up
- Password recovery
- Password change
- User information update

<br>

### What is OAuth?

**OAuth: A method of delegating account management to a third-party service.**

**The main participants in OAuth**

- **Resource Owner**: The entity that grants permission to access their information on the authorization server.
    - The user who is using the service.
- **Resource Server**: The entity that holds the resource owner's information and protects it.
    - Examples include Naver, Google, Kakao, etc.
- **Authorization Server**: An application responsible for issuing tokens that allow the client to access the resource owner's information.
- **Client Application**: The entity that authenticates with the authorization server and uses the resource owner's information.
    - The service being developed, the application that uses OAuth.

**Four ways for clients to obtain resource owner information**:

1. **Authorization Code Grant Type**: The most well-known authentication method in OAuth 2.0.
   - The client uses this method to access resources, obtaining an authorization code and an access token for the resource owner.
2. **Implicit Grant Type**: A method mainly used by JavaScript web applications that have no backend server.
   - The client sends a request, and after the resource owner's authentication, it receives an access token directly without additional steps like exchanging an authorization code.
3. **Resource Owner Password Credentials Grant Type**: A method where the client exchanges the user's credentials (like a password) for an access token.
4. **Client Credentials Grant Type**: A method where the client obtains an access token outside of the user context to request access to specific resources.

### What is the Authorization Code Grant Type?

The most commonly used and well-known method in OAuth 2.0.
![image](https://github.com/user-attachments/assets/5b9c446e-4bd3-4b0c-8876-efc5105dbdd1)


## Implementing Login with JWT + OAuth2

JWT replaces sessions for maintaining authentication. The Access Token is used for API requests, while the Refresh Token reissues new Access Tokens when they expire.
### **Advantages**

1. There is no need to store the session state on the server; the client can maintain the authentication state through tokens, which makes the server more scalable.
2. By using a Refresh Token, users can get a new Access Token when the previous one expires, allowing them to stay logged in without re-authenticating.
3. In distributed environments, JWT can maintain authentication state across multiple servers without session synchronization, making it easier to scale in cloud environments.

### **What is JWT?**

**JWT (JSON Web Token)** consists of three parts: Header, Payload, and Signature. 
It provides token-based authentication. 
Access Tokens can have a short lifespan, while Refresh Tokens are used for longer sessions, allowing users to stay authenticated without compromising security.

### 1. **OAuth2 Authentication Success**

- Once the user successfully authenticates with an OAuth2 provider (e.g., Google), the `OAuth2UserCustomService` retrieves the user's information. This class handles new user registration or existing user updates using the information returned from the OAuth2 provider when the user logs in.

```java
@RequiredArgsConstructor
@Service
public class OAuth2UserCustomService extends DefaultOAuth2UserService {

    private final UserRepository userRepository;

    @Override
    public OAuth2User loadUser(OAuth2UserRequest userRequest) throws OAuth2AuthenticationException {
        OAuth2User user = super.loadUser(userRequest); // Returns a user object based on the request
        saveOrUpdate(user);

        return user;
    }

    // Update user if exists, otherwise create a new user
    private User saveOrUpdate(OAuth2User oAuth2User) {
        Map<String, Object> attributes = oAuth2User.getAttributes();

        String email = (String) attributes.get("email");
        String name = (String) attributes.get("name");

        User user = userRepository.findByEmail(email)
                .map(entity -> entity.update(name))
                .orElse(User.builder()
                        .email(email)
                        .nickname(name)
                        .build());

        return userRepository.save(user);
    }
}
```

### 2. **JWT Issuance**

- After the user is authenticated in `OAuth2SuccessHandler`, JWT (Access Token and Refresh Token) is generated using `TokenProvider`.
    - **Access Token**: Issued with a short lifespan (e.g., 1 day) to maintain the user's authenticated state.
    - **Refresh Token**: Has a longer validity (e.g., 14 days) and is used to reissue an Access Token when it expires.

```java
@RequiredArgsConstructor
@Component
public class OAuth2SuccessHandler extends SimpleUrlAuthenticationSuccessHandler {

    public static final String REFRESH_TOKEN_COOKIE_NAME = "refresh_token";  
    public static final Duration REFRESH_TOKEN_DURATION = Duration.ofDays(14);  
    public static final Duration ACCESS_TOKEN_DURATION = Duration.ofDays(1);  
    public static final String REDIRECT_PATH = "/articles";  

    private final TokenProvider tokenProvider;
    private final RefreshTokenRepository refreshTokenRepository;
    private final OAuth2AuthorizationRequestBasedOnCookieRepository authorizationRequestRepository;
    private final UserService userService;

    @Override
    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException {
        OAuth2User oAuth2User = (OAuth2User) authentication.getPrincipal();
        User user = userService.findByEmail((String) oAuth2User.getAttributes().get("email"));

        String refreshToken = tokenProvider.generateToken(user, REFRESH_TOKEN_DURATION);
        saveRefreshToken(user.getId(), refreshToken);
        addRefreshTokenToCookie(request, response, refreshToken);

        String accessToken = tokenProvider.generateToken(user, ACCESS_TOKEN_DURATION);
        String targetUrl = getTargetUrl(accessToken);

        clearAuthenticationAttributes(request, response);
        getRedirectStrategy().sendRedirect(request, response, targetUrl);
    }

    private void saveRefreshToken(Long userId, String newRefreshToken) {
        RefreshToken refreshToken = refreshTokenRepository.findByUserId(userId)
                .map(entity -> entity.update(newRefreshToken))
                .orElse(new RefreshToken(userId, newRefreshToken));

        refreshTokenRepository.save(refreshToken);
    }

    private void addRefreshTokenToCookie(HttpServletRequest request, HttpServletResponse response, String refreshToken) {
        int cookieMaxAge = (int) REFRESH_TOKEN_DURATION.toSeconds();  

        CookieUtil.deleteCookie(request, response, REFRESH_TOKEN_COOKIE_NAME);  
        CookieUtil.addCookie(response, REFRESH_TOKEN_COOKIE_NAME, refreshToken, cookieMaxAge);  
    }

    private void clearAuthenticationAttributes(HttpServletRequest request, HttpServletResponse response) {
        super.clearAuthenticationAttributes(request);  
        authorizationRequestRepository.removeAuthorizationRequestCookies(request, response);  
    }

    private String getTargetUrl(String token) {
        return UriComponentsBuilder.fromUriString(REDIRECT_PATH)
                .queryParam("token", token)
                .build()
                .toUriString();
    }
}
```

```java
@RequiredArgsConstructor
@Service
public class TokenProvider {

    private final JwtProperties jwtProperties;

    public String generateToken(User user, Duration expiredAt) {
        Date now = new Date();
        return makeToken(new Date(now.getTime() + expiredAt.toMillis()), user);
    }

    private String makeToken(Date expiry, User user) {
        Date now = new Date();

        return Jwts.builder()
                .setHeaderParam(Header.TYPE, Header.JWT_TYPE)
                .setIssuer(jwtProperties.getIssuer())
                .setIssuedAt(now)
                .setExpiration(expiry)
                .setSubject(user.getEmail())
                .claim("id", user.getId())
                .signWith(SignatureAlgorithm.HS256, jwtProperties.getSecretKey())
                .compact();
    }

    public boolean validToken(String token) {
        try {
            Jwts.parser()
                    .setSigningKey(jwtProperties.getSecretKey())
                    .parseClaimsJws(token);
            return true;
        } catch (Exception e) {
            return false;
        }
    }

    public Authentication getAuthentication(String token) {
        Claims claims = getClaims(token);
        Set<SimpleGrantedAuthority> authorities = Collections.singleton(new SimpleGrantedAuthority("ROLE_USER"));

        return new UsernamePasswordAuthenticationToken(new org.springframework.security.core.userdetails.User(claims.getSubject(), "", authorities), token, authorities);
    }

    public Long getUserId(String token) {
        Claims claims = getClaims(token);
        return claims.get("id", Long.class);
    }

    private Claims getClaims(String token) {
        return Jwts.parser()
                .setSigningKey(jwtProperties.getSecretKey())
                .parseClaimsJws(token)
                .getBody();
    }
}
```

### 3. **Storing Refresh Token in Cookies**

- The Refresh Token is stored in cookies by `OAuth2SuccessHandler`. This allows the client to maintain the session with the server, automatically sending the Refresh Token when requesting a new Access Token if the previous one has expired.

### 4. **Access Token Delivery and Redirection**

- After a successful OAuth2 login, the server includes the Access Token in the URL query parameters and redirects the client to the designated path. The client stores this Access Token and includes it in the headers for subsequent requests to authenticate itself.

### 5. **Using the Access Token**

- The client includes the Access Token in its API requests. The server verifies the token to maintain the user's authenticated state. When the Access Token expires, the client uses the stored Refresh Token to request a new Access Token.

### 6. **Reissuing Access Token with Refresh Token**

- **Expired Access Token**: When the Access Token expires, the client sends the saved Refresh Token to the server to request a new Access Token. The `TokenService` verifies the Refresh Token and generates a new Access Token.

```java
@RequiredArgsConstructor
@Service
public class TokenService {

    private final TokenProvider tokenProvider;
    private final RefreshTokenService refreshTokenService;
    private final UserService userService;

    public String createNewAccessToken(String refreshToken) {
        if (!tokenProvider.validToken(refreshToken)) {
            throw new IllegalArgumentException("Unexpected token");
        }

        Long userId = refreshTokenService.findByRefreshToken(refreshToken).getUserId();
        User user = userService.findById(userId);

        return tokenProvider.generateToken(user, Duration.ofHours(2));
    }
}
```

**Why store the Refresh Token in cookies?**: Security and convenience.

1. **Automatic transmission**: The Refresh Token stored in cookies is automatically sent with each request, so the user doesn’t need to manage it manually.
2. **Security**: The Refresh Token is protected from access by browser scripts using **HTTPOnly** and **Secure** attributes. Additionally, HTTPS ensures the token isn’t intercepted during communication.
